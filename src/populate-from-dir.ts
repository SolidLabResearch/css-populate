import fs from "fs";
import { readFile } from "node:fs/promises";

import { addAuthZFile, addAuthZFiles, uploadPodFile } from "./css-upload.js";
import { AuthFetchCache } from "./auth-fetch-cache.js";
import { CONTENT_TYPE_BYTE } from "./content-type.js";
import { CliArgs } from "./css-populate-args.js";
import { makeDirListing } from "./file-utils.js";
import { accountEmail, ProvidedAccountInfo } from "./generate-users.js";

export interface ProvidedAccountAndDirInfo extends ProvidedAccountInfo {
  accountDir: string;
}

export async function findAccountsFromDir(
  dir: string
): Promise<ProvidedAccountAndDirInfo[]> {
  //This expects a very specific dir layout, typically generated by jbr
  //  in dir there must be subdirs named for accounts/pods.
  //      (accounts and pod names are always assumed to be the same)

  const listing = await makeDirListing(dir, false);
  // return listing.dirs.map((d) => d.name);
  const providedAccountInfo: ProvidedAccountAndDirInfo[] = [];
  for (const accountDir of listing.dirs) {
    const ai = {
      username: accountDir.name,
      password: "password",
      podName: accountDir.name,
      email: accountEmail(accountDir.name),
      index: providedAccountInfo.length,
      accountDir: accountDir.fullPath,
    };
    providedAccountInfo.push(ai);
  }
  return providedAccountInfo;
}

/**
 *
 * @param authFetchCache
 * @param cli
 * @param cssBaseUrl the URL for the CCS server to populate
 * @param generatedDataBaseDir a dir with subdirs per pod for the server to populate. (= NOT a dir with subdirs per server!)
 * @param addAclFiles
 * @param addAcrFiles
 */
export async function populatePodsFromDir(
  authFetchCache: AuthFetchCache,
  cli: CliArgs,
  cssBaseUrl: string,
  generatedDataBaseDir: string,
  addAclFiles: boolean = false,
  addAcrFiles: boolean = false
) {
  //This expects a very specific dir layout, typically generated by jbr
  //  in generatedDataBaseDir there must be subdirs named for accounts/pods.
  //      (accounts and pod names are always assumed to be the same)
  //  in these subdirs, are the files to be stored in these pod

  console.debug(
    `populatePodsFromDir(cssBaseUrl=${cssBaseUrl}, generatedDataBaseDir=${generatedDataBaseDir}, addAclFiles=${addAclFiles}, addAcrFiles=${addAcrFiles})`
  );

  const dirListing = await makeDirListing(generatedDataBaseDir, false);

  if (dirListing.files) {
    console.warn(
      `Found non-dir where expecting only account dirs: ${dirListing.files
        .map((f) => f.name)
        .join(", ")}`
    );
  }
  const providedAccountInfo: ProvidedAccountAndDirInfo[] =
    await findAccountsFromDir(generatedDataBaseDir);
  for (const ai of providedAccountInfo) {
    const authFetch = await authFetchCache.getAuthFetcher(ai);

    const podListing = await makeDirListing(ai.accountDir, true);

    // console.log(
    //   `populatePodsFromDir will create dirs in pod ${account}: ${JSON.stringify(
    //     podListing.dirs.map((e) => e.pathFromBase),
    //     null,
    //     3
    //   )}`
    // );
    console.log(
      `populatePodsFromDir will upload files to pod ${
        ai.podName
      }: ${JSON.stringify(
        podListing.files.map((e) => e.pathFromBase),
        null,
        3
      )}`
    );

    //We don't need to create containers, they should be auto created according to the spec
    // for (const dirToCreate of podListing.dirs) {
    //   const podFilePath = `${accountDirPath}/${dirToCreate.pathFromBase}`;
    //   //TODO create dir in pod
    // }

    for (const fileToUpload of podListing.files) {
      const podFilePath = fileToUpload.fullPath;
      const filePathInPod = fileToUpload.pathFromBase;
      const fileName = fileToUpload.name;
      const fileDirInPod = filePathInPod.substring(
        0,
        filePathInPod.length - fileName.length
      );
      cli.v1(
        `Uploading. account=${ai.username} file='${podFilePath}' filePathInPod='${filePathInPod}'`
      );

      const fileContent = await readFile(podFilePath, { encoding: "utf8" });
      await uploadPodFile(
        cli,
        cssBaseUrl,
        ai,
        fileContent,
        filePathInPod,
        authFetch,
        CONTENT_TYPE_BYTE, //TODO use correct content type
        false
      );

      const authZTypes: ("ACP" | "WAC")[] = [];
      if (addAclFiles) {
        authZTypes.push("WAC");
      }
      if (addAcrFiles) {
        authZTypes.push("ACP");
      }
      for (const authZType of authZTypes) {
        await addAuthZFile(
          cli,
          cssBaseUrl,
          ai,
          authFetch,
          fileDirInPod,
          fileName,
          true,
          false,
          false,
          true,
          authZType,
          false
        );
      }
    }
  }
}
